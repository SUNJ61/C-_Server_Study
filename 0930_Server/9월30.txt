C#으로 서버 만들기

#0. 복습 (이전 서버,단일 쓰레드를 이용하여 클리이언트와 서버간에 문자열 데이터 송신 수신)
            -> 데이터 한개가 이동해야 다른 데이터 전송가능
            -> socket.connet() : 연결 요청 , socket.Accept() : 연결 요청을 확인
#1. 멀티 쓰레드를 이용하여 클라이언트와 서버간의 데이터 통신
     -블로킹 함수를 논블로킹 - 비동기 함수로 바꾸어 적용하기. (금일 Accept 함수만 바꿈.)
====================================================================================
#0. 복습

 [OSI 7계층]
  -통신 과정을 세분화하여 7개의 계층으로 구분, 실제 네트워크 환경에서는 모든 계층이 명확히 구분되어 사용되지는 않습니다.

   1. 물리 계층(Physical Layer): 하드웨어 전송 기술을 다룹니다.
   2. 데이터 링크 계층(Data Link Layer): 두 장치 간의 데이터 전송을 처리합니다.
   3. 네트워크 계층(Network Layer): 데이터 패킷의 라우팅을 담당합니다.
   4. 전송 계층(Transport Layer): 데이터 전송의 신뢰성을 보장합니다.
   5. 세션 계층(Session Layer): 통신 세션을 관리합니다.
   6. 표현 계층(Presentation Layer): 데이터 형식을 변환합니다.
   7. 응용 계층(Application Layer): 최종 사용자의 응용 프로그램과 직접적으로 관련됩니다.

 [TCP/IP 5계층]
  -인터넷 통신을 위해 최적화되어 있으며, 실제 네트워크 장비와 프로토콜 개발에 널리 사용됩니다.

   1. 응용 계층(Application Layer): OSI 모델의 응용, 표현, 세션 계층에 해당하는 기능을 합니다.
   2. 전송 계층(Transport Layer): OSI 모델의 전송 계층과 유사한 역할을 합니다.
   3. 인터넷 계층(Internet Layer): OSI 모델의 네트워크 계층에 해당합니다.
   4. 네트워크 인터페이스 계층(Network Interface Layer): OSI 모델의 데이터 링크 계층과 물리 계층을 합친 계층입니다.
   5. 물리 계층(Physical Layer): OSI 모델과 동일하게 하드웨어 전송 기술에 관한 계층입니다.

-> 참고 : https://velog.io/@euisuk-chung/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-OSI-7%EA%B3%84%EC%B8%B5-vs-TCP-5%EA%B3%84%EC%B8%B5

#1. 멀티 쓰레드를 이용하여 클라이언트와 서버간의 데이터 통신

 [이전 서버의 문제점]
  -중간에 클라이언트의 연결이 끊기더라도 될 때까지 계속 연결을 찾고 있어 문제가 발생

 [블로킹, 논블로킹]
  -블로킹 : A함수가 B함수를 호출하면 제어권을 A가 호출한 B함수에게 넘겨주는 것.
              즉, A함수는 B함수의 처리가 끝날 때 까지 멈춰 있어야한다.
              (Receive와 Send / Accept과 Connet함수가 블로킹 함수이다.) ->서버에서는 이 함수를 논블로킹으로 바꾸어야함.

  -논블로킹 : A함수가 B함수를 호출하더라도 제어권을 A함수가 계속 가지고 있는 것.
                 즉, A함수가 B함수를 호출하여 처리가 시작되더라도 A함수는 멈추지 않고 계속 실행을 이어가는 것.

 [동기, 비동기]
  -동기(Synchronous) : A함수가 B함수를 호출 한 뒤 함수의 B의 리턴 값을 신경 쓰는 것. 

  -비동기(Asynchronous) : A함수가 B함수를 호출 할 때 콜백 함수를 같이 전달, 함수B가 완료되면 콜백함수가 실행된다.
                                 즉, A함수는 B함수가 끝나든, 끝나지 않든 신경 쓰지 않는다.

  -Sync-Blocking : 함수A는 함수B의 리턴값을 필요로 한다(동기). 그래서 제어권을 함수B에게 넘겨주고,
                       함수B가 실행을 완료하여 리턴값과 제어권을 돌려줄때까지 기다린다(블로킹).

  -Sync-Nonblocking : A함수는 B함수를 호출한다. 이 때 A 함수는 B 함수에게 제어권을 주지 않고,
                            자신의 코드를 계속 실행한다(논블로킹).
                            A함수는 B함수의 리턴값이 필요하기 때문에,
                            중간중간 B함수에게 함수 실행을 완료했는지 물어본다(동기).
                            =>유니티에 startcoroutine과 비슷

  -Async-Nonblocking : A함수는 B함수를 호출한다.
                              제어권을B 함수에 주지 않고, 자신이 계속 가지고 있는다(논블로킹).
                              B함수를 호출한 이후에도 멈추지 않고 자신의 코드를 계속 실행한다.
                              B함수를 호출할 때 콜백함수를 함께 준다.
                              B함수는 자신의 작업이 끝나면 A함수가 준 콜백 함수를 실행한다(비동기).

  -Async-blocking : 잘사용하지 않음.
                         A함수는 B함수의 리턴값에 신경쓰지 않고, 콜백함수를 보낸다(비동기).
                         B함수의 작업에 관심없음에도 불구하고, A함수는 B함수에게 제어권을 넘긴다(블로킹).
                         A함수는 자신과 관련 없는 B함수의 작업이 끝날 때까지 기다려야 한다.